<?php

/**
 * @file
 * Implementation of hook_form_alter.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Url;
use Drupal\node\Entity\Node;
use Drupal\node\Entity\NodeType;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\field\Entity\FieldStorageConfig;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Drupal\field\Entity\FieldConfig;
use Drupal\node\NodeInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\CloseModalDialogCommand;

/**
 * @file
 * Implements hook_form_alter.
 */

/**
 * Add a machine name field to the heritage text.
 *
 * Opens and closes form in modal dialog.
 */
function heritage_schema_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // print_r($form_id);
  // echo "</br>";.
  if ($form_id == 'node_heritage_text_form') {
    $form['field_machine_name']['#access'] = FALSE;
    $form['field_levels']['#access'] = FALSE;
    $form['field_level_labels']['#access'] = FALSE;
    // $form['#validate'][] = '_heritage_text_form_validate';
  }
  if ($form_id == 'node_heritage_text_edit_form') {
    $form['field_machine_name']['#access'] = FALSE;
    $form['field_levels']['#access'] = FALSE;
    $form['field_level_labels']['#access'] = FALSE;
  }
  if ($form_id == 'node_source_node_form') {
    $form['actions']['submit']['#submit'][] = 'redirect_to_text_node';

  }

  if ($form_id == 'node_heritage_text_form' || $form_id == 'node_heritage_text_edit_form' || $form_id == 'node_source_node_form' || $form_id == 'node_source_node_edit_form') {
    $form['#attached']['library'][] = 'core/drupal.dialog.ajax';
    // Echo $_GET['textid'];
    // print_r($_GET['textid']);.
    $options = [
      'attributes' => [
        'class' => ['use-ajax', 'button'],
        'data-dialog-type' => 'modal',
        'data-dialog-options' => json_encode(['width' => 400]),
      ],
      // 'query' => ['destination' => \Drupal::url('<current>')],
    ];
    $form['field_author_name']['add_term_link'] = [
      '#title' => t('Add author'),
      '#type' => 'link',
      '#url' => Url::fromRoute('entity.taxonomy_term.add_form', ['taxonomy_vocabulary' => 'authors'], $options),

    ];

    $form['field_publisher_name']['add_term_link'] = [
      '#title' => t('Add publisher'),
      '#type' => 'link',
      '#url' => Url::fromRoute('entity.taxonomy_term.add_form', ['taxonomy_vocabulary' => 'publishers'], $options),

    ];

    // $form['actions']['submit']['#submit'][] = '_modal_form_example_ajax_submit';
    // $form['actions']['submit']['#attributes']['class'][] = 'use-ajax-submit';
  }

  /* The second function adds an extra submit function (which will be executed after Drupal finishes processing the node) and the first function adds the command to close the Dialog when the node has been created. */

  if ($form_id == 'taxonomy_term_authors_form' || $form_id == 'taxonomy_term_publishers_form') {
    $form['actions']['submit']['#submit'][] = '_modal_form_example_ajax_submit';
    $form['actions']['submit']['#attributes']['class'][] = 'use-ajax-submit';

  }

}

/**
 * @file
 * Implements hook functions.
 */

/**
 * Presaves the text id in the field_heritage_text_id.
 */
function heritage_schema_node_presave(EntityInterface $entity) {

  if ($entity->getEntityTypeId() == 'node' && $entity->bundle() == 'source_node') {
    $text_node = $_GET["textid"];
    // print_r($text_node);exit;
    // Hook_entity_presave gets called before the entity is saved
    // And also before you save the edits.
    if (isset($text_node)) {
      $entity->field_heritage_text_id->target_id = $text_node;

    }

  }

}

/**
 * Create content type and vocabulary and add basic fields.
 */
function heritage_schema_node_insert(NodeInterface $node) {

  if ($node->getType() == 'heritage_text') {
    $response = new RedirectResponse(\Drupal::url('heritage_schema.addtoc', ['node' => $node->id()], ['absolute' => TRUE]));
    $response->send();
  }
  if ($node->getType() == "source_node") {

    $params = [
      'source_nodeId' => $node->id(),
      'title' => $node->title->value,
      'language' => $node->field_language->target_id,
      'author' => $node->field_author_name->target_id,
      'format' => [$node->field_format->value],
      'type' => $node->field_type->value,
      'parent_id' => $node->field_parent_source->target_id,
    ];

    _add_source_info($params, $_GET["textid"]);

  }

}

/**
 * Updates source info.
 */
function heritage_schema_entity_update(EntityInterface $entity) {

  if ($entity->getEntityTypeId() == 'node' && $entity->bundle() == 'source_node') {

    $params = [
    // 'source_nodeId' => $node->id(),
      'title' => $entity->title->value,
      'language' => $entity->field_language->target_id,
      'author' => $entity->field_author_name->target_id,
      'format' => [$entity->field_format->value],
      'type' => $entity->field_type->value,
      'parent_id' => $entity->field_parent_source->target_id,

    ];

    $machine_names = []; $types = [];$cardinality = [];
    $format = '';
    $format_tmp_array = $params['format'];
    for ($i = 0; $i < count($format_tmp_array); $i++) {
      if ($i == 0) {
        $format = $format_tmp_array[$i];
      }
      else {
        $format = $format . ',' . $format_tmp_array[$i];
      }
    }
    $old_source_info = db_query("SELECT * FROM `heritage_source_info` WHERE id = :sourceid", [':sourceid' => $entity->id()])->fetchAll();
    $textid = $old_source_info[0]->text_id;
    $node = Node::load($textid);

    // Update source node structure in database.
    db_update('heritage_source_info')
      ->fields([
        'title' => $params['title'],
        'language' => $params['language'],
        'author' => $params['author'],
        'format' => $format,
        'type' => $params['type'],
        'parent_id' => $params['parent_id'],

      ])
      ->condition('id', $entity
        ->id())
      ->execute();

    $textname = $node->field_machine_name->value;
    $field_name = 'field_' . $textname . '_' . $entity->id();
    for ($i = 0; $i < count($format_tmp_array); $i++) {
      $machine_names[] = $field_name . '_' . strtolower($format_tmp_array[$i]);
      if ($format_tmp_array[$i] == 'text') {
        $types[] = 'text_long';
        $labels[] = $params['title'];
        $cardinality[] = 1;
      }
      if ($format_tmp_array[$i] == 'audio') {
        $types[] = 'file';
        $labels[] = $format_tmp_array[$i] . ' of ' . $params['title'];
        $cardinality[] = -1;
      }
      if ($format_tmp_array[$i] == 'video') {
        $types[] = 'file';
        $labels[] = $format_tmp_array[$i] . ' of ' . $params['title'];
        $cardinality[] = -1;
      }
    }

  }
}

/**
 * Delete test source.
 */
function heritage_schema_entity_delete(EntityInterface $entity) {

  db_delete('heritage_source_info')
    ->condition('id', $entity->id())
    ->execute();

}

/**
 * Custom function to add a field to an entity.
 *
 * @param string $bundle
 *   Name of the entity bundle.
 * @param object $entity_type
 *   Type of entity ie. whether node/taxonomy/user.
 * @param array $labels
 *   Array of field labels.
 * @param string $machine_names
 *   Array of Machine Names of the field.
 * @param array $field_types
 *   Array of Field Types to be added.
 */
function add_other_fields($bundle, $entity_type, array $labels, $machine_names, array $field_types, array $format_tmp_array, array $cardinality) {
  for ($i = 0; $i < count($field_types); $i++) {
    $fieldname = strtolower($machine_names[$i]);
    if ($field_types[$i] == 'entity_reference') {
      $handler = 'default:taxonomy_term';
      $handler_settings = ['target_bundles' => [$bundle]];
      $settings_create = ['target_type' => 'taxonomy_term'];
      $settings_config = ['handler' => $handler, 'handler_settings' => $handler_settings];
    }
    elseif ($field_types[$i] == 'file' && $format_tmp_array[$i] == 'audio') {
      $handler = 'default';
      $handler_settings = [];
      $settings_create = [];
      $settings_config = [
        'handler' => $handler,
        'handler_settings' => $handler_settings,
        'file_extensions' => 'mp3',
        'file_directory' => $bundle,
      ];
    }
    elseif ($field_types[$i] == 'file' && $format_tmp_array[$i] == 'video') {
      $handler = 'default';
      $handler_settings = [];
      $settings_create = [];
      $settings_config = [
        'handler' => $handler,
        'handler_settings' => $handler_settings,
        'file_extensions' => 'mp4',
        'file_directory' => $bundle,
      ];
    }

    else {
      $handler = 'default';
      $handler_settings = [];
      $settings_create = [];
      $settings_config = [
        'handler' => $handler,
        'handler_settings' => $handler_settings,
      ];
    }
    if (empty($fieldStorageMicrositesfield = FieldStorageConfig::loadByName($entity_type, $fieldname))) {
      $fieldStorage = FieldStorageConfig::create(
      [
        'field_name'             => $fieldname,
        'entity_type'            => $entity_type,
        'type'                   => $field_types[$i],
        'translatable'           => TRUE,
        'persist_with_no_fields' => FALSE,
        'cardinality'             => $cardinality[$i],
        'settings'                 => $settings_create,
      ]
      );
      $fieldStorageSaved = $fieldStorage->save();
    }
    $all_bundle_fields = \Drupal::service('entity_field.manager')->getFieldDefinitions($entity_type, $bundle);
    if (!isset($all_bundle_fields[$fieldname])) {
      $field = FieldConfig::create(
                        [
                          'entity_type' => $entity_type,
                          'field_name' => $fieldname,
                          'bundle' => $bundle,
                          'label' => $labels[$i],
                          'settings' => $settings_config,
                        ]
      );
      $field->save();

      // Make the field available in the entity creation form.
      entity_get_form_display($entity_type, $bundle, 'default')
        ->setComponent(
      $fieldname
      )
        ->save();

      // Assign display settings for the 'default' and 'teaser' view modes.
      entity_get_display($entity_type, $bundle, 'default')
        ->setComponent($fieldname)
        ->save();
    }
    else {
      $field_info = FieldConfig::loadByName($entity_type, $bundle, $fieldname);
      $field_info->setLabel($labels[$i]);
      $field_info->save();
    }
  }
  $message = t("Fields added successfully");
  return $message;
}

/**
 * Custom function to add a vocabulary for the heritage text.
 *
 * @param string $title
 *   Title of the content type.
 * @param string $machineName
 *   Unique machine name of the content type.
 */
function add_vocabulary($title, $machineName) {
  $vocabularies = Vocabulary::loadMultiple();
  if (!isset($vocabularies[$machineName])) {
    $vocabulary = Vocabulary::create(
    [
      'vid' => $machineName,

      'description' => t('Vocabulary for storing the levels of heritage text <em> @title </em>.', ['@title' => $title]),
      'name' => $title,
    ]
    );
    $vocabulary->save();
    $labels = ['Index', 'Title', 'No.of Sub Levels', 'Position'];
    $machine_names = [
      'field_index',
      'field_title',
      'field_sub_levels',
      'field_position',
    ];
    $types = ['integer', 'text', 'integer', 'text'];
    $cardinality = [1, 1, 1, 1];
    $format_tmp_array = [];
    $field_status = add_other_fields($vocabulary->id(), 'taxonomy_term', $labels, $machine_names, $types, $format_tmp_array, $cardinality);
  }
  $message = t(
        "Vocabulary @a added successfully",
        ['@a' => $title]
  );
  return $message;
}

/**
 * Custom function to add a term to a vocabulary.
 *
 * @param int $id
 *   Index of the term - Relative position in the heritage text structure.
 * @param string $term_name
 *   Name of the taxonomy term that has to be created.
 * @param string $vid
 *   Vocabulary name of the term.
 * @param int $parent
 *   Parent id of the term, if any.
 */
function add_term($id, $term_name, $vid, $parent = NULL) {
  $term = Term::create([
    'vid' => $vid,
    'name' => $term_name,
    'parent' => [$parent],
  ]);
  $term->set('field_index', $id);
  if ($parent != NULL) {
    $parent_term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($parent);
    $parent_position = $parent_term->field_position->value;
    $sublevels = $parent_term->field_sub_levels->value;
    if (!isset($sublevels)) {
      $sublevels = 1;
    }
    else {
      $sublevels = $sublevels + 1;
    }
    $parent_term->field_sub_levels->value = $sublevels;
    $parent_term->save();
    $term_position = $parent_position . '.' . $id;
  }
  else {
    $term_position = $id;
  }
  $term->set('field_position', $term_position);
  $term->save();
  $message = t(
        "Taxonomy term @a added successfully",
        ['@a' => $term_name]
  );
  return $message;
}

/**
 * Custom function to delete a term to a vocabulary.
 *
 * @param int $id
 *   Index of the term - Relative position in the heritage text structure.
 * @param string $term_name
 *   Name of the taxonomy term that has to be deleted.
 * @param string $vid
 *   Vocabulary name of the term.
 * @param int $parent
 *   Parent id of the term, if any.
 */
function delete_term($id, $term_name, $vid, $parent = NULL) {
  if ($parent == NULL) {
    $parent = 0;
  }
  // Get the taxonomy term id, load the term and delete it.
  $tid_to_delete = db_query("SELECT tid FROM `taxonomy_term_field_data` WHERE name = :name AND vid = :vid AND tid IN (SELECT entity_id FROM `taxonomy_term__parent` WHERE parent_target_id = :parent)", [
    ':name' => $term_name,
    ':vid' => $vid,
    ':parent' => $parent,
  ])->fetchField();
  $controller = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  $term_to_delete = $controller->load($tid_to_delete);
  $controller->delete($term_to_delete);

  if ($parent != 0) {
    $parent_term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($parent);
    $sublevels = $parent_term->field_sub_levels->value;
    if (!isset($sublevels)) {
      $sublevels = 0;
    }
    else {
      $sublevels = $sublevels - 1;
    }
    $parent_term->field_sub_levels->value = $sublevels;
    $parent_term->save();
  }
  $message = t(
        "Taxonomy term @a deleted successfully",
        ['@a' => $term_name]
  );
  return $message;
}

/**
 * Custom function to create a content type.
 *
 * @param string $title
 *   Title of the content type.
 * @param string $machineName
 *   Unique machine name of the content type.
 */
function create_content_type($title, $machineName) {
  $content_type = NodeType::create([
    'type' => $machineName,
    'name' => $title,

    'description' => t('Content type for <em>@title</em> with trasnliteration enabled',
  ['@title' => $title]),
    'new_revision' => FALSE,
    'status' => TRUE,
    'preview_mode' => 0,
    'display_submitted' => FALSE,
  ]);
  $content_type->save();
  ($content_type);
  return $content_type;
}

/**
 * Batch operation for creating taxonomy terms.
 */
function create_taxonomy_terms_batch($id, $vid, $term_name, $parent = NULL, $operation_details, &$context) {
  // Create taxonomy term.
  $term_status = add_term($id, $term_name, $vid, $parent);

  // Store some results for post-processing in the 'finished' callback.
  $context['results'][] = $id;

  // Optional message displayed under the progressbar.
  $context['message'] = t('Running Batch "@id" @details',
        ['@id' => $id, '@details' => $operation_details]
  );
}

/**
 * Batch 'finished' callback used by create_taxonomy_terms_batch.
 */
function create_taxonomy_terms_batch_finished($success, $results, $operations) {
  $messenger = \Drupal::messenger();
  if ($success) {
    // Here we could do something meaningful with the results.
    // We just display the number of nodes we processed...
    $messenger->addMessage(t('@count terms created.', ['@count' => count($results)]));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $messenger->addMessage(
    t('An error occurred while processing @operation with arguments : @args',
                [
                  '@operation' => $error_operation[0],
                  '@args' => print_r($error_operation[0], TRUE),
                ]
    )
    );
  }
}

/**
 * Batch operation for deleting taxonomy terms.
 */
function delete_taxonomy_terms_batch($id, $vid, $term_name, $operation_details, &$context, $parent = NULL) {
  // Delete taxonomy term.
  $term_status = delete_term($id, $term_name, $vid, $parent);

  // Store some results for post-processing in the 'finished' callback.
  $context['results'][] = $id;

  // Optional message displayed under the progressbar.
  $context['message'] = t('Running Batch "@id" @details',
        ['@id' => $id, '@details' => $operation_details]
  );
}

/**
 * Batch 'finished' callback used by delete_taxonomy_terms_batch.
 */
function delete_taxonomy_terms_batch_finished($success, $results, $operations) {
  $messenger = \Drupal::messenger();
  if ($success) {
    // Here we could do something meaningful with the results.
    // We just display the number of nodes we processed...
    $messenger->addMessage(t('@count terms deleted.', ['@count' => count($results)]));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $messenger->addMessage(
    t('An error occurred while processing @operation with arguments : @args',
                [
                  '@operation' => $error_operation[0],
                  '@args' => print_r($error_operation[0], TRUE),
                ]
    )
    );
  }
}

/**
 * Custom function to add source to a text.
 *
 * @param array $params
 *   An array containing title, language, format, author and type of the source.
 * @param int $textid
 *   Unique Id of the heritage text.
 *
 * @return bool
 *   Returns a boolean
 */
function _add_source_info(array $params, $textid) {
  $machine_names = []; $types = [];$cardinality = [];
  $format = '';
  $format_tmp_array = $params['format'];
  for ($i = 0; $i < count($format_tmp_array); $i++) {
    if ($i == 0) {
      $format = $format_tmp_array[$i];
    }
    else {
      $format = $format . ',' . $format_tmp_array[$i];
    }
  }
  $node = Node::load($textid);
  // Insert source node structure to database.
  $db = \Drupal::database();
  $source_id = $db->insert('heritage_source_info')
    ->fields([
      'id' => $params['source_nodeId'],
      'text_id' => $textid,
      'title' => $params['title'],
      'language' => $params['language'],
      'author' => $params['author'],
      'format' => $format,
      'type' => $params['type'],
      'parent_id' => $params['parent_id'],
                                // Added the source node id.
    ])
    ->execute();
  $textname = $node->field_machine_name->value;
  $field_name = 'field_' . $textname . '_' . $source_id;
  for ($i = 0; $i < count($format_tmp_array); $i++) {
    $machine_names[] = $field_name . '_' . strtolower($format_tmp_array[$i]);
    if ($format_tmp_array[$i] == 'text') {
      $types[] = 'text_long';
      $labels[] = $params['title'];
      $cardinality[] = 1;
    }
    if ($format_tmp_array[$i] == 'audio') {
      $types[] = 'file';
      $labels[] = $format_tmp_array[$i] . ' of ' . $params['title'];
      $cardinality[] = -1;
    }
    if ($format_tmp_array[$i] == 'video') {
      $types[] = 'file';
      $labels[] = $format_tmp_array[$i] . ' of ' . $params['title'];
      $cardinality[] = -1;
    }
  }

  // print_r($textname);print_r($field_name);print_r($machine_names);exit;
  // pass the $format_tmp_array in the function.
  $field_status = add_other_fields($textname, 'node', $labels, $machine_names, $types, $format_tmp_array, $cardinality);
  return TRUE;
}

/**
 * Custom function to update source of a text.
 *
 * @param array $params
 *   An array containing title, language, format, author and type of the source.
 * @param int $sourceid
 *   Unique Id of the source of the heritage text.
 *
 * @return bool
 *   Return a boolean
 */
function _update_source_info(array $params, $sourceid) {
  $machine_names = []; $types = [];$cardinality = [];
  $format = '';
  $format_tmp_array = $params['format'];
  for ($i = 0; $i < count($format_tmp_array); $i++) {
    if ($i == 0) {
      $format = $format_tmp_array[$i];
    }
    else {
      $format = $format . ',' . $format_tmp_array[$i];
    }
  }
  $old_source_info = db_query("SELECT * FROM `heritage_source_info` WHERE id = :sourceid", [':sourceid' => $sourceid])->fetchAll();
  $textid = $old_source_info[0]->text_id;
  $node = Node::load($textid);
  // Update source node structure in database.
  $db = \Drupal::database();
  $db->update('heritage_source_info')
    ->fields([
      'title' => $params['title'],
      'language' => $params['language'],
      'author' => $params['author'],
      'format' => $format,
      'type' => $params['type'],
      'parent_id' => $params['parent_id'],
    ])
    ->condition('id', $sourceid, '=')
    ->execute();
  $textname = $node->field_machine_name->value;
  $field_name = 'field_' . $textname . '_' . $sourceid;
  for ($i = 0; $i < count($format_tmp_array); $i++) {
    $machine_names[] = $field_name . '_' . strtolower($format_tmp_array[$i]);
    if ($format_tmp_array[$i] == 'text') {
      $types[] = 'text_long';
      $labels[] = $params['title'];
      $cardinality[] = 1;
    }
    if ($format_tmp_array[$i] == 'audio') {
      $types[] = 'file';
      $labels[] = $format_tmp_array[$i] . ' of ' . $params['title'];
      $cardinality[] = -1;
    }
    if ($format_tmp_array[$i] == 'video') {
      $types[] = 'file';
      $labels[] = $format_tmp_array[$i] . ' of ' . $params['title'];
      $cardinality[] = -1;
    }
  }
  // print_r($textname);print_r($field_name);print_r($machine_names);exit;
  $field_status = add_other_fields($textname, 'node', $labels, $machine_names, $types, $format_tmp_array, $cardinality);
  return TRUE;
}

/**
 * Function to find the depth of the given element.
 */
function find_depth($input, $startDepth = 0) {
  if (is_array($input)) {
    $max = $startDepth;
    foreach ($input as $i) {
      // Check what the depth of the given element is.
      $result = find_depth($i, $startDepth + 1);
      // We only care about the maximum value.
      if ($result > $max) {
        $max = $result;
      }
    }
    return $max;
  }
  else {
    // This isn't an array, so it's assumed not to be a container.
    // This doesn't add any depth to the parent array,
    // So just return $startDepth.
    return $startDepth;
  }
}

/**
 * Custom function to redirect source of a text.
 */
function redirect_to_text_node(array $form, FormStateInterface $form_state) {

  $nid = $_GET["textid"];

  $form_state->setRedirect('entity.node.canonical', ['node' => $nid]);
}

/**
 * Close the Modal and redirect the user to the current page.
 *
 * @param array $form
 *   The form that will be altered.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   FormState Object.
 */
function _modal_form_example_ajax_submit(array $form, FormStateInterface &$form_state) {
  $response = new AjaxResponse();
  $response->addCommand(new CloseModalDialogCommand());
  $form_state->setResponse($response);

}
